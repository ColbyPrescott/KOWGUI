Node types:
- Custom
    - Custom code will be run through BaseNode::SetTick
    - Custom properties should be stored in std::map<std::string, void*>
      It will be up to the user to cast it to the right type
    - Icon-like functions will be called with reference to that node, 
      position and stuff accessed through there
    - This is designed for something simple like a cross visible node. If the user wants their
      own actual type of node like rounded rectangle, they can add it to the source code themself
- Toggleable
    - If supplied an id or something, toggles could store their state on SD card
    - Basic on off, but also int counter. Custom modulo feedback node
- Unfocused
    - Feedback node that will only enable when nearest parent interactable is not focused
- Activated
    - Feedback node that will only enable when nearest toggleable parent is set to true
- Deactivated
- Circle
- Line
- Image
    - Must create or take image buffer for faster drawing
- Polygon
    - Rotation
    - Scaling
    - Gradients
- Clip
    - vex::brain::lcd::setClipRegion to mask all children inside node's area
    - Some possibilities may not work from the parenting system... Maybe make a node that will copy the position of another?
        Keep things simple, user may write location copying code into BaseNode::SetTick
    - How might each interactable react to being clipped?
        - Clip should stop interactable from being selected
        - Clip border should unfocus clickable
        - Clip border should not stop draggable from moving (for scrollable windows)



Features:
- Disablement
    - SetEnable and SetDisable callback functions?
- ID system
  - Classes maybe? Add a function to return a list of all elements with a specific class added?
- Removing nodes
  - Delete keyword
  - Recursively call delete on children
  - Remove ID
- Prefabs
    - Functions to prebuild useful systems
    - Every node will have shallowID and... maybe class? For customizability
    - Keyboard
    - Graph
- Animation
    - Currently possible by constantly updating a value manually, but should specific functionality be added?
    - Bezier curve animation?
    - Animation states like Unity?
    - Whatever CSS does like CSS?
    - Should be able to attatch an animation to events like node getting enabled. Should user 
      set this with some sort of node->SetEnable([](){node->Animate();}) thing?
- Controller input
    - Integration with WIP KOWGUIController? KOWGUI shouldn't force user into using other KOW libraries
    - Cursor
        - Full joystick like MTV3GUI
        - Joystick or buttons could control velocity
        - Set which joystick / buttons are being used
    - Menu
        - Put a scrollable menu on controller screen while enabled
        - Do so when a special type of node is enabled?



Refactoring and other code stuff:
- Some comments have the text "TO DO" so they can be found with grep
- Move all cpp files into the headers so a user will only need to copy the include folder
    - On second look at PROS, it seems like precompiled binaries could be a viable option
- Could callback functions also have a version that get a pointer to its own node? That way not EVERYTHING needs an ID to be accessible
- Use of 'p' before pointer names in inconsistent
- Finish adding list of default color names
- Should positions be represented by floats and rounded in the screen functions? Increasing a node's 
  position at a constant rate could have much more precision a lot easier
- Usage of clipping region will need to have a system like JS canvas transform save restore



Other:
- Figure out what email to use when posting to GitHub and figure 
  out how to update it across all commits
- Icon of a melting cow lol. Knock On Wood Graphical User Interface. KOWGUI. Gooey cow. :D
- Um, trailer maybe?? Some sort of cool GitHub page. A brand new GUI library without PROS. 
  Some people might be like me and dislike the idea of PROS forcing itself into every part
  of code without choice. If I want KOWGUI to stop drawing on the screen, KOWGUI::Stop().
  PROS says it ports LVGL which itself has an amazing looking webpage, but then I look for examples 
  of it being used on the V5 brain and nothing stands out as entirely mind blowing...
  And no hate on PROS or anything. I just don't see what useful things it can do that VEX C++ can't :/
- Panels, like the slides in MTV3GUI, should be implemented by the user. FMI, git checkout 3356326ce248446c97b50c49b8326b6143ee4463



Random notes:
- Users will have to replace the -fno-rtti compiler flag with -frtti on line 95 of vex/mkenv.mk
  VEX may have disabled dynamic_cast for a reason, but, I need it. This project will be sooo much messier without it
- Users will have to add an extra depth to the source code depth in makefile